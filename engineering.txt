03/02/2025

(Did via VS Code Liveshare in Dhall, so little commit history. Unit tests added by mention.)

Starting work today on the logical clocks. Before we begin, we have an outline of roughly what we want to complete:

1) Each vm will be an object of a VirtualMachine class that keeps track of the other clocks
    Also useful since we can set clock speed at the beginning!
2) Listening sockets need to be run in a thread in parallel via threading and handling requests. This is a bit tough
since we also do not have a main "server," but rather computers talking to each other over distinct sockets.
3) When clock speed is chosen, we need to sleep for time/clock seconds for each event.
4) From what we have decided, vector clocks are NOT mentioned. So, internal events update clock by 1 and when it receives another clock's time,
new time is max(our_time, their_time) + 1 as described in lecture.
5) Logging would also be best by type of message sent/received. I.e., having [INTERNAL] or [RECEIVE] at the beginning to easily read the logs.

Created the class and passed all info. Issue is getting sockets to connect to each other.

Ok, so it looks like we need to run all the "setup_connection" in a seperate thread. Then, before running all of the machines,
we run a separate function "connect_to_peers" that needs to be run following all initialization.

UNIT TESTING:
- Added tests for connecting sockets
- Added tests for sending information between machines

Ok, great. All seem to be connected. Now, we can think about our main loop.

When running our main loop, we sleep for 1/clock seconds per internal.
Randomize number, if 1 send to first peer, if 2 send to second. If 3rd, iterate and send to others.
If we have an internal event. just update clock by 1.
If we RECEIVED something, use the max formula: clock = max(clock, receive_clock) + 1

UNIT TESTING:
- VM can send message to 1 machine
- VM can send messages to both machines
- When received message, clock updates correctly (max function)
- When internal message, clock updates correctly (+1)

Ok, adding all log statements with eventypes and we should be done.
Next, we can document our results. We've also added a config file for detailing ports, host, and time to run.

RESULTS: We run our scale model five times for a minute each (logs stored under log_hist directory). 
We then have a brief program that extracts clock information from each of the log files
and analyzes the clock information. We report below, for each run, the (randomly generated)
clock rates for each machine (higher numbers indicate more ticks per real world second),
along with the final logical clock time and the average change in the logical clock value
between logged events. 

Run 1:
Clock rates: [3, 4, 1]
Final logical clock time: [236, 236, 184]
Average step sizes: [1.33, 1.0, 3.1]

Run 2:
Clock rates: [5, 3, 6]
Final logical clock time: [351, 349, 351]
Average step sizes: [1.19, 1.97, 1.0]

Run 3:
Clock rates: [1, 3, 4]
Final logical clock time: [163, 233, 236]
Average step sizes: [2.75, 1.31, 1.0]

Run 4:
Clock rates: [5, 3, 2]
Final logical clock time: [294, 291, 286]
Average step sizes: [1.0, 1.64, 2.42]

Run 5:
Clock rates: [6, 2, 4]
Final logical clock time: [351, 334, 348]
Average step sizes: [1.0, 2.82, 1.48]

We notice two primary patterns:
(1) Faster clock rates correspond to larger final logical clock values. This makes sense
because faster clock rates correspond to more actions taken